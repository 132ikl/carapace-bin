package cmd

import (
	"github.com/rsteube/carapace"
	"github.com/rsteube/carapace-bin/completers/ant_completer/cmd/action"
	"github.com/spf13/cobra"
)

var rootCmd = &cobra.Command{
	Use:   "ant",
	Short: "software tool for automating software build processes",
	Long:  "https://ant.apache.org/",
	Run:   func(cmd *cobra.Command, args []string) {},
}

func Execute() error {
	carapace.Override(carapace.Opts{
		LongShorthand: true,
	})
	return rootCmd.Execute()
}
func init() {
	carapace.Gen(rootCmd).Standalone()

	rootCmd.Flags().Bool("-execdebug", false, "print ant exec line generated by this launch script")
	rootCmd.Flags().Bool("-h", false, "print this message and ant help")
	rootCmd.Flags().Bool("-help", false, "print this message and ant help")
	rootCmd.Flags().Bool("-noconfig", false, "suppress sourcing of configuration files")
	rootCmd.Flags().Bool("-usejikes", false, "enable use of jikes by default, unless set explicitly in configuration files")
	rootCmd.Flags().Bool("autoproxy", false, "Java1.5+: use the OS proxy settings")
	rootCmd.Flags().String("buildfile", "", "use given buildfile")
	rootCmd.Flags().Bool("debug", false, "print debugging information")
	rootCmd.Flags().Bool("diagnostics", false, "print information that might be helpful to")
	rootCmd.Flags().Bool("emacs", false, "produce logging information without adornments")
	rootCmd.Flags().String("f", "", "use given buildfile")
	rootCmd.Flags().String("file", "", "use given buildfile")
	rootCmd.Flags().String("find", "", "(s)earch for buildfile towards the root of")
	rootCmd.Flags().Bool("help", false, "print this message and exit")
	rootCmd.Flags().String("inputhandler", "", "the class which will handle input requests")
	rootCmd.Flags().Bool("k", false, "execute all targets that do not depend on failed target(s)")
	rootCmd.Flags().Bool("keep-going", false, "execute all targets that do not depend on failed target(s)")
	rootCmd.Flags().String("l", "", "use given file for log")
	rootCmd.Flags().String("lib", "", "specifies a path to search for jars and classes")
	rootCmd.Flags().String("listener", "", "add an instance of class as a project listener")
	rootCmd.Flags().String("logfile", "", "use given file for log")
	rootCmd.Flags().String("logger", "", "the class which is to perform logging")
	rootCmd.Flags().String("main", "", "override Ant's normal entry point")
	rootCmd.Flags().String("nice", "", "A niceness value for the main thread")
	rootCmd.Flags().Bool("noclasspath", false, "Run ant without using CLASSPATH")
	rootCmd.Flags().Bool("noinput", false, "do not allow interactive input")
	rootCmd.Flags().Bool("nouserlib", false, "Run ant without using the jar files from ${user.home}/.ant/lib")
	rootCmd.Flags().Bool("projecthelp", false, "print project help information and exit")
	rootCmd.Flags().String("propertyfile", "", "load all properties from file with -D properties taking precedence")
	rootCmd.Flags().Bool("quiet", false, "be extra quiet")
	rootCmd.Flags().String("s", "", "(s)earch for buildfile towards the root of")
	rootCmd.Flags().Bool("silent", false, "print nothing but task outputs and build failures")
	rootCmd.Flags().Bool("verbose", false, "be extra verbose")
	rootCmd.Flags().Bool("version", false, "print the version information and exit")

	// TODO class completions
	carapace.Gen(rootCmd).FlagCompletion(carapace.ActionMap{
		"buildfile":    carapace.ActionFiles(".xml"),
		"f":            carapace.ActionFiles(".xml"),
		"file":         carapace.ActionFiles(".xml"),
		"l":            carapace.ActionFiles(),
		"lib":          carapace.ActionDirectories(),
		"logfile":      carapace.ActionFiles(),
		"propertyfile": carapace.ActionFiles(),
	})

	carapace.Gen(rootCmd).PositionalAnyCompletion(
		carapace.ActionCallback(func(c carapace.Context) carapace.Action {
			path := ""
			if flag := rootCmd.Flag("buildfile"); flag.Changed {
				path = flag.Value.String()
			}
			if flag := rootCmd.Flag("file"); flag.Changed {
				path = flag.Value.String()
			}
			if flag := rootCmd.Flag("f"); flag.Changed {
				path = flag.Value.String()
			}
			return action.ActionTargets(path).Invoke(c).Filter(c.Args).ToA()
		}),
	)
}
